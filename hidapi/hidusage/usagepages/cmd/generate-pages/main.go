package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"math/big"
	"os"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/neuroplastio/neio-agent/hidapi/hidusage/usagepages"
	"github.com/yuin/goldmark"
	meta "github.com/yuin/goldmark-meta"
	"github.com/yuin/goldmark/extension"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/text"
)

type pageInfo struct {
	code          uint16
	alias         string
	name          string
	ordinalPrefix string
	usages        []usageInfo
}

type usageInfo struct {
	usageID    uint16
	usageName  string
	usageTypes []string
	reserved   bool
}

func main() {
	generatePages(os.Args[1])
	generateKeycodes(os.Args[2])
}

func generatePages(outputFile string) {
	entries, err := usagepages.FS.ReadDir("data")
	if err != nil {
		panic(err)
	}
	var pages []pageInfo
	for _, entry := range entries {
		file, err := usagepages.FS.Open("data/" + entry.Name())
		if err != nil {
			panic(err)
		}
		fb, err := io.ReadAll(file)
		_ = file.Close()
		if err != nil {
			panic(err)
		}
		pageInfo, err := parsePage(entry.Name(), fb)
		if err != nil {
			panic(err)
		}
		pages = append(pages, pageInfo)
	}

	buf := bytes.NewBuffer(nil)
	_, _ = buf.WriteString("//go:build !generate\n")
	_, _ = buf.WriteString("// Code generated by generate-pages. DO NOT EDIT.\n")
	_, _ = buf.WriteString("package usagepages\n\n")
	_, _ = buf.WriteString("const (\n")
	for _, page := range pages {
		_, _ = buf.WriteString("\t" + strcase.ToCamel(strings.TrimSuffix(page.name, " Page")) + " uint16 = 0x" + fmt.Sprintf("%02x", page.code) + " // " + page.name + "\n")
	}
	_, _ = buf.WriteString(")\n")

	_, _ = buf.WriteString("\nvar pages = map[uint16]PageInfo{\n")
	for _, page := range pages {
		_, _ = buf.WriteString(fmt.Sprintf("\t0x%02x: {\n", page.code))
		_, _ = buf.WriteString("\t\tCode: 0x" + fmt.Sprintf("%02x", page.code) + ",\n")
		_, _ = buf.WriteString("\t\tAlias: " + fmt.Sprintf("%q", page.alias) + ",\n")
		_, _ = buf.WriteString("\t\tName: " + fmt.Sprintf("%q", page.name) + ",\n")
		switch {
		case page.ordinalPrefix != "":
			_, _ = buf.WriteString("\t\tUsages: newOrdinalUsageCollection(" + fmt.Sprintf("%q", page.ordinalPrefix) + "),\n")
		case len(page.usages) == 0:
		default:
			_, _ = buf.WriteString("\t\tUsages: newUsageTable().\n")
			for i, usage := range page.usages {
				var types []string
				for _, usageType := range usage.usageTypes {
					types = append(types, "UsageType"+usageType)
				}
				dot := "."
				if i == len(page.usages)-1 {
					dot = ","
				}
				if len(types) > 0 {
					_, _ = buf.WriteString(fmt.Sprintf("\t\t\tusage(0x%02x, %q, %s)%s\n", usage.usageID, usage.usageName, strings.Join(types, ", "), dot))
				} else {
					_, _ = buf.WriteString(fmt.Sprintf("\t\t\tusage(0x%02x, %q)%s\n", usage.usageID, usage.usageName, dot))
				}
			}
		}
		_, _ = buf.WriteString("\t},\n")
	}
	_, _ = buf.WriteString("}\n")

	generated := buf.Bytes()
	formatted, formatErr := format.Source(generated)
	if formatErr != nil {
		err = os.WriteFile(outputFile, generated, 0644)
		fmt.Println(formatErr.Error())
		os.Exit(1)
	}

	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		panic(err)
	}
}

func parseMarkdownTable(str string) [][]string {
	lines := strings.Split(str, "\n")
	var table [][]string
	for _, line := range lines {
		if !strings.HasPrefix(line, "|") {
			continue
		}
		line = strings.ReplaceAll(line, "\\|", "_PIPE_")
		fields := strings.Split(line, "|")
		var row []string
		for _, field := range fields {
			field = strings.ReplaceAll(field, "_PIPE_", "|")
			row = append(row, strings.Trim(field, " "))
		}
		table = append(table, row)
	}
	return table
}

var usageParsers = map[string]func([]byte) ([]usageInfo, error){
	"0x07-keyboard-keypad.md": parseKeyboard,
	"0x09-button.md":          nil,
	"0x10-ordinal.md":         nil,
}

var knownUsageTypes = map[string]struct{}{
	"LC":  {},
	"OOC": {},
	"MC":  {},
	"OSC": {},
	"RTC": {},

	"Sel": {},
	"SV":  {},
	"SF":  {},
	"DV":  {},
	"DF":  {},

	"NAry": {},
	"CA":   {},
	"CL":   {},
	"CP":   {},
	"US":   {},
	"UM":   {},
}

var usageTypeMap = map[string]string{
	"Buffered Bytes": "CL",
}

func parsePage(fileName string, fb []byte) (pageInfo, error) {
	md := goldmark.New(
		goldmark.WithExtensions(
			extension.Table,
			meta.Meta,
		),
	)
	context := parser.NewContext()
	md.Parser().Parse(text.NewReader(fb), parser.WithContext(context))
	data := meta.Get(context)

	var usages []usageInfo
	var err error
	if parser, ok := usageParsers[fileName]; ok {
		if parser != nil {
			usages, err = parser(fb)
			if err != nil {
				return pageInfo{}, err
			}
		}
	} else {
		table := parseMarkdownTable(string(fb))
		for _, fields := range table {
			if len(fields) != 5 {
				continue
			}
			n := new(big.Int)
			n, ok := n.SetString(strings.TrimSpace(fields[1]), 16)
			if !ok {
				continue
			}
			usageID := uint16(n.Int64())
			usageName := strings.Join(strings.Fields(fields[2]), " ")
			usageTypes := strings.Split(strings.TrimSpace(fields[3]), "/")
			var validUsageTypes []string
			for _, usageType := range usageTypes {
				if usageType == "" {
					continue
				}
				if mappedType, ok := usageTypeMap[usageType]; ok {
					usageType = mappedType
				}
				if _, ok := knownUsageTypes[usageType]; !ok {
					fmt.Printf("Skipping unknown usage type in %s: %q\n", fileName, usageType)
					continue
				}
				validUsageTypes = append(validUsageTypes, usageType)
			}
			usages = append(usages, usageInfo{
				usageID:    usageID,
				usageName:  usageName,
				usageTypes: validUsageTypes,
				reserved:   usageName == "Reserved",
			})
		}
	}
	prefix, _ := data["ordinalPrefix"].(string)
	return pageInfo{
		code:          uint16(data["code"].(int)),
		alias:         data["alias"].(string),
		ordinalPrefix: prefix,
		name:          data["name"].(string),
		usages:        usages,
	}, nil
}

func generateKeycodes(outputFile string) {
	file, err := usagepages.FS.Open("data/0x07-keyboard-keypad.md")
	if err != nil {
		panic(err)
	}
	fb, err := io.ReadAll(file)
	_ = file.Close()
	if err != nil {
		panic(err)
	}
	keycodes, err := parseKeyboard(fb)
	if err != nil {
		panic(err)
	}

	buf := bytes.NewBuffer(nil)
	_, _ = buf.WriteString("//go:build !generate\n")
	_, _ = buf.WriteString("// Code generated by generate-keycodes. DO NOT EDIT.\n")
	_, _ = buf.WriteString("package usagepages\n")
	_, _ = buf.WriteString("const (\n")
	for _, keycode := range keycodes {
		_, _ = buf.WriteString("\tKey" + formatKeyName(keycode.usageID, keycode.usageName) + " uint8 = 0x" + fmt.Sprintf("%x", keycode.usageID) + " // " + keycode.usageName + "\n")
	}
	_, _ = buf.WriteString(")\n")

	_, _ = buf.WriteString("\nvar keyNameMap = map[uint8]string{\n")
	for _, keycode := range keycodes {
		_, _ = buf.WriteString("\t" + fmt.Sprintf("0x%x", keycode.usageID) + ": " + fmt.Sprintf("%q", formatKeyName(keycode.usageID, keycode.usageName)) + ",\n")
	}
	_, _ = buf.WriteString("}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		panic(err)
	}
}

var keyNameMap = map[string]string{
	"ESCAPE":             "Esc",
	"Return (ENTER)":     "Enter",
	"DELETE (Backspace)": "Backspace",
	"-":                  "Minus",
	"+":                  "Plus",
	"=":                  "Equal",
	"[":                  "LeftBracket",
	"]":                  "RightBracket",
	"\\":                 "Backslash",
	"NON-US \\":          "NonUSBackslash",
	"NON-US #":           "NonUSHash",
	";":                  "Semicolon",
	"'":                  "Quote",
	"`":                  "GraveAccent",
	",":                  "Comma",
	".":                  "Period",
	"/":                  "Slash",
	"SysReq/Attention":   "SysReqAttention",
	"Clear/Again":        "ClearAgain",
	"CrSel/Props":        "CrSelProps",
	"Currency Sub-unit":  "CurrencySubUnit",
	"|":                  "Pipe",
	"||":                 "DoublePipe",
	":":                  "Colon",
	"#":                  "Hash",
	". and Delete":       "PeriodDelete",
	"*":                  "Asterisk",
	"(":                  "LeftParenthesis",
	")":                  "RightParenthesis",
	"{":                  "LeftBrace",
	"}":                  "RightBrace",
	"<":                  "LessThan",
	">":                  "GreaterThan",
	"^":                  "Caret",
	"%":                  "Percent",
	"&":                  "Ampersand",
	"&&":                 "DoubleAmpersand",
	"!":                  "Exclamation",
	"+/-":                "PlusMinus",
	"@":                  "At",
}

var validNameRegex = regexp.MustCompile(`^[a-zA-Z0-9_\s]+$`)

func formatKeyName(code uint16, name string) string {
	kp := false
	if strings.HasPrefix(name, "Keypad") {
		kp = true
		name = strings.TrimPrefix(name, "Keypad ")
	}
	if strings.HasPrefix(name, "Keyboard") {
		name = strings.TrimPrefix(name, "Keyboard ")
		if index := strings.Index(name, " and "); index != -1 {
			name = strings.ToUpper(name[:index])
		}
	}
	if newName, ok := keyNameMap[name]; ok {
		name = newName
	}
	if !validNameRegex.MatchString(name) {
		fmt.Println("Invalid name:", name)
		return "Code" + strings.ToUpper(fmt.Sprintf("%x", code))
	}
	if kp {
		return "Kp" + strcase.ToCamel(name)
	}
	return strcase.ToCamel(name)
}

func parseKeyboard(fb []byte) ([]usageInfo, error) {
	var keycodes []usageInfo
	table := parseMarkdownTable(string(fb))
	for _, fields := range table {
		if len(fields) < 3 {
			continue
		}
		n := new(big.Int)
		n, ok := n.SetString(strings.Trim(fields[1], " "), 16)
		if !ok {
			continue
		}
		keycodes = append(keycodes, usageInfo{
			usageID:    uint16(n.Int64()),
			usageName:  strings.Trim(fields[2], " "),
			usageTypes: []string{"Sel"},
		})
	}
	return keycodes, nil
}
