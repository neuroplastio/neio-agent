package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"math/big"
	"os"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/neuroplastio/neuroplastio/hidapi/hidusage/usagepages"
	"github.com/yuin/goldmark"
	meta "github.com/yuin/goldmark-meta"
	"github.com/yuin/goldmark/extension"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/text"
)

type pageInfo struct {
	code uint16
	name string
}

func main() {
	generatePages(os.Args[1])
	generateKeycodes(os.Args[2])
}

func generatePages(outputFile string) {
	entries, err := usagepages.FS.ReadDir(".")
	if err != nil {
		panic(err)
	}
	var pages []pageInfo
	for _, entry := range entries {
		file, err := usagepages.FS.Open(entry.Name())
		if err != nil {
			panic(err)
		}
		fb, err := io.ReadAll(file)
		_ = file.Close()
		if err != nil {
			panic(err)
		}
		pageInfo, err := parsePage(fb)
		if err != nil {
			panic(err)
		}
		pages = append(pages, pageInfo)
	}

	buf := bytes.NewBuffer(nil)
	_, _ = buf.WriteString("// Code generated by generate-pages. DO NOT EDIT.\n")
	_, _ = buf.WriteString("package usagepages\n\n")
	_, _ = buf.WriteString("const (\n")
	for _, page := range pages {
		_, _ = buf.WriteString("\t" + strcase.ToCamel(strings.TrimSuffix(page.name, " Page")) + " uint16 = 0x" + fmt.Sprintf("%x", page.code) + " // " + page.name + "\n")
	}
	_, _ = buf.WriteString(")\n")

	_, _ = buf.WriteString("\nvar pageNameMap = map[uint16]string{\n")
	for _, page := range pages {
		_, _ = buf.WriteString("\t" + fmt.Sprintf("0x%x", page.code) + ": " + fmt.Sprintf("%q", page.name) + ",\n")
	}
	_, _ = buf.WriteString("}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(buf.String())
		panic(err)
	}

	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		panic(err)
	}
}

func parsePage(fb []byte) (pageInfo, error) {
	md := goldmark.New(
		goldmark.WithExtensions(
			extension.Table,
			meta.Meta,
		),
	)
	context := parser.NewContext()
	md.Parser().Parse(text.NewReader(fb), parser.WithContext(context))
	data := meta.Get(context)
	return pageInfo{
		code: uint16(data["code"].(int)),
		name: data["name"].(string),
	}, nil
}

func generateKeycodes(outputFile string) {
	file, err := usagepages.FS.Open("0x07-keyboard-keypad.md")
	if err != nil {
		panic(err)
	}
	fb, err := io.ReadAll(file)
	_ = file.Close()
	if err != nil {
		panic(err)
	}
	keycodes, err := parseKeycodes(fb)
	if err != nil {
		panic(err)
	}

	buf := bytes.NewBuffer(nil)
	_, _ = buf.WriteString("// Code generated by generate-keycodes. DO NOT EDIT.\n")
	_, _ = buf.WriteString("package usagepages\n")
	_, _ = buf.WriteString("const (\n")
	for _, keycode := range keycodes {
		_, _ = buf.WriteString("\t" + formatKeyName(keycode.usageID, keycode.usageName) + " uint8 = 0x" + fmt.Sprintf("%x", keycode.usageID) + " // " + keycode.usageName + "\n")
	}
	_, _ = buf.WriteString(")\n")

	_, _ = buf.WriteString("\nvar keyNameMap = map[uint8]string{\n")
	for _, keycode := range keycodes {
		_, _ = buf.WriteString("\t" + fmt.Sprintf("0x%x", keycode.usageID) + ": " + fmt.Sprintf("%q", formatKeyName(keycode.usageID, keycode.usageName)) + ",\n")
	}
	_, _ = buf.WriteString("}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		panic(err)
	}
}

var keyNameMap = map[string]string{
	"ESCAPE":             "Esc",
	"Return (ENTER)":     "Enter",
	"DELETE (Backspace)": "Backspace",
	"-":                  "Minus",
	"=":                  "Equal",
	"[":                  "LeftBracket",
	"]":                  "RightBracket",
	"\\":                 "Backslash",
	"NON-US \\":          "NonUSBackslash",
	"NON-US #":           "NonUSSharp",
	";":                  "Semicolon",
	"'":                  "Apostrophe",
	"`":                  "GraveAccent",
	",":                  "Comma",
	".":                  "Period",
	"/":                  "Slash",
}

var validNameRegex = regexp.MustCompile(`^[a-zA-Z0-9_\s]+$`)

func formatKeyName(code uint8, name string) string {
	if strings.HasPrefix(name, "Keyboard") {
		name = strings.TrimPrefix(name, "Keyboard ")
		if index := strings.Index(name, " and "); index != -1 {
			name = strings.ToUpper(name[:index])
		}
	}
	if newName, ok := keyNameMap[name]; ok {
		name = newName
	}
	if !validNameRegex.MatchString(name) {
		fmt.Println("Invalid name:", name)
		return "KeyCode" + strings.ToUpper(fmt.Sprintf("%x", code))
	}
	return "Key" + strcase.ToCamel(name)
}

type keycode struct {
	usageID   uint8
	usageName string
}

func parseKeycodes(fb []byte) ([]keycode, error) {
	// just parse line by line for now
	lines := strings.Split(string(fb), "\n")
	var keycodes []keycode
	for _, line := range lines {
		if !strings.HasPrefix(line, "|") {
			continue
		}
		fields := strings.Split(line, "|")
		if len(fields) < 3 {
			continue
		}
		n := new(big.Int)
		n, ok := n.SetString(strings.Trim(fields[1], " "), 16)
		if !ok {
			continue
		}
		keycodes = append(keycodes, keycode{
			usageID:   uint8(n.Int64()),
			usageName: strings.Trim(fields[2], " "),
		})
	}

	return keycodes, nil
}
